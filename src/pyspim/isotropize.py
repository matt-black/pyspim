""" Isotropization utilities. 

Individual views from diSPIM volumes are typically acquired with uneven spacing in one of the directions, but analysis requires cubic pixels.
These are utilities to upsample the axis with uneven spacing relative to the camera pixel size. 

This can be done either by direct interpolation (`interpolate`) or by upsampling in Fourier space (`fourier_upsample`), using the technique described in [1].

References
---
[1] Stein, et al. "Fourier interpolation stochastic..."
    doi:10.1364/OE.23.016154
"""
import math

import cupy

from .typing import NDArray
from ._util import get_fft_module, get_ndimage_module


def interpolate(vol : NDArray, pixel_size : float, step_size : float,
                axis : int=0, **kwargs) -> NDArray:
    """interpolate Upsample an axis by interpolation. Function will upsample specified `axis` by assuming it has spacing `step_size` such that the output voxel is cubic, `pixel_size**3`.

    Args:
        vol (NDArray): input volume
        pixel_size (float): pixel size in real (space) units
        step_size (float): step size in real (space) units
        axis (int, optional): axis to upsample. Defaults to 0.
        **kwargs: passed to `ndimage.zoom`
    
    Returns:
        NDArray: 
    """

    n_dim = len(vol.shape)
    assert axis < n_dim and axis >= 0, \
        "axis must be in range [0, len(vol.shape))"
    ndi = get_ndimage_module(vol)
    resc = [1.,] * n_dim
    resc[axis] = step_size / pixel_size
    return ndi.zoom(vol, resc, **kwargs)


def fourier_upsample(vol : NDArray, pixel_size : float, step_size : float,
                     axis : int=0) -> NDArray:
    """fourier_upsample Upsample an axis by Fourier upsampling.

    Args:
        vol (NDArray): input volume
        pixel_size (float): pixel size in real (space) units.
        step_size (float): step size in real (space) units
        axis (int, optional): axis to upsample. Defaults to 0.

    Returns:
        NDArray
    """

    n_dim = len(vol.shape)
    assert n_dim == 2 or n_dim == 3, \
        "input must be a 2D image or 3D volume"
    assert axis < n_dim and axis >= 0, \
        "axis must be in range [0, len(vol.shape))"
    xp = cupy.get_array_module(vol)
    fft = get_fft_module(vol)
    # mirror the volume on the relevant axis and convert to fourier domain
    ax_sze = vol.shape[axis]
    mirror_padding = [(0, 0) for _ in range(n_dim)]
    mirror_padding[axis] = ((ax_sze//2, ax_sze//2))
    fourier = fft.fftshift(fft.rfftn(
        xp.pad(vol, mirror_padding, mode='symmetric')
    ))
    # calculate how much we need to pad to make the upsampling work
    # see Eqn. 9 of fSOFI paper
    n12 = math.ceil((2 * ax_sze - 1) / 2)
    delta = int(math.ceil((step_size / pixel_size) * n12 - n12))
    # pad fourier domain image with zeros
    zero_padding = [(0, 0) for _ in range(n_dim)]
    zero_padding[axis] = (delta, delta)
    fourier = xp.pad(fourier, zero_padding, mode='constant', constant_values=0)
    out = fft.irfftn(fft.ifftshift(fourier))
    # trim out extra stuff generated by the padding
    n_mid = math.floor(step_size / pixel_size * ax_sze)
    nmh = n_mid // 2
    cent = out.shape[axis]
    if n_dim == 3:
        if axis == 0:
            return out[cent-nmh:cent+nmh,...]
        elif axis == 1:
            return out[:,cent-nmh,cent+nmh,:]
        else:
            return out[...,cent-nmh:cent+nmh]
    else:  # n_dim == 2
        if axis == 0:
            return out[cent-nmh:cent+nmh,:]
        else:
            return out[:,cent-nmh:cent+nmh]
