import math

import cupy

from .typing import NDArray
from ._util import get_fft_module, get_scipy_module


def interpolate(vol : NDArray, pixel_size : float, step_size : float,
                axis : int=0, **kwargs):
    """upsample an axis by interpolation.
        function will upsample the specified `axis` by assuming it has
        spacing `step_size` such that the output voxel is `pixel_size**3`
        `**kwargs` are passed to `ndimage.zoom`

    :param vol: input volume
    :type vol: NDArray
    :param pixel_size: pixel size in real (space) units
    :type pixel_size: float
    :param step_size: step size in real (space) units
    :type step_size: float
    :param axis: axis to upsample
    :type axis: int
    :returns: upsampled volume
    :rtype: NDArray
    """

    n_dim = len(vol.shape)
    assert axis < n_dim and axis >= 0, \
        "axis must be in range [0, len(vol.shape))"
    sp = get_scipy_module(vol)
    resc = [1.,] * n_dim
    resc[axis] = step_size / pixel_size
    return sp.ndimage.zoom(vol, resc, **kwargs)


def fourier_upsample(vol : NDArray, pixel_size : float, step_size : float,
                     axis : int=0):
    """upsample an axis by fourier upsampling.
        function will upsample the specified `axis` by assuming it has
        spacing `step_size` such that the output voxel is `pixel_size**3`

        originally described in [1], this technique will preserve the
        input spectrum by zero-padding the fourier transform of the input

    References
    ---
    [1] Stein, et al. "Fourier interpolation stochastic..."
        doi:10.1364/OE.23.016154

    :param vol: input volume
    :type vol: NDArray
    :param pixel_size: pixel size in real (space) units
    :type pixel_size: float
    :param step_size: step size in real (space) units
    :type step_size: float
    :param axis: axis to upsample
    :type axis: int
    :returns: upsampled volume
    :rtype: NDArray
    """

    n_dim = len(vol.shape)
    assert n_dim == 2 or n_dim == 3, \
        "input must be a 2D image or 3D volume"
    assert axis < n_dim and axis >= 0, \
        "axis must be in range [0, len(vol.shape))"
    xp = cupy.get_array_module(vol)
    fft = get_fft_module(vol)
    # mirror the volume on the relevant axis and convert to fourier domain
    ax_sze = vol.shape[axis]
    mirror_padding = [(0, 0) for _ in range(n_dim)]
    mirror_padding[axis] = ((ax_sze//2, ax_sze//2))
    fourier = fft.fftshift(fft.rfftn(
        xp.pad(vol, mirror_padding, mode='symmetric')
    ))
    # calculate how much we need to pad to make the upsampling work
    # see Eqn. 9 of fSOFI paper
    n12 = math.ceil((2 * ax_sze - 1) / 2)
    delta = int(math.ceil((step_size / pixel_size) * n12 - n12))
    # pad fourier domain image with zeros
    zero_padding = [(0, 0) for _ in range(n_dim)]
    zero_padding[axis] = (delta, delta)
    fourier = xp.pad(fourier, zero_padding, mode='constant', constant_values=0)
    out = fft.irfftn(fft.ifftshift(fourier))
    # trim out extra stuff generated by the padding
    n_mid = math.floor(step_size / pixel_size * ax_sze)
    nmh = n_mid // 2
    cent = out.shape[axis]
    if n_dim == 3:
        if axis == 0:
            return out[cent-nmh:cent+nmh,...]
        elif axis == 1:
            return out[:,cent-nmh,cent+nmh,:]
        else:
            return out[...,cent-nhm:cent+nmh]
    else:  # n_dim == 2
        if axis == 0:
            return out[cent-nmh:cent+nmh,:]
        else:
            return out[:,cent-nmh:cent+nmh]
